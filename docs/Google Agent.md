# Agents 简介

作者： Alan Blount, Antonio Gulli, Shubham Saboo, Michael Zimmermann, and VladimirVuskovic

Google

翻译：古早程序员 小红书 ID：2202716350

2025 年 11 月

![](images/3e5d109582007fa5f4e4fd2da494cd6ee81b05d54b5303087bf19f1144c73a5f.jpg)

# Agent 简介与 Agent 架构

## 鸣谢

### 内容贡献者

Enrique Chan

Mike Clark

Derek Egan

Anant Nawalgaria

Kanchana Patlolla

Julia Wiesinger

### 策划与编辑

Anant Nawalgaria

Kanchana Patlolla

### 设计师

Michael Lanning

# 目录

Agent 简介与 Agent 架构. 2

鸣谢..

目录. 3

从预测型 AI 到自主 Agent..

AI Agent 简介.. 2

Agentic 问题解决流程. 3

Agentic 系统分类.

核心 Agent 架构：模型、工具与编排.. .11

模型：AI Agent 的“大脑”. .11

工具：AI Agent 的“双手” .12

编排层.. 13

Agent 部署与服务. . 15

Agent Ops：应对不可预测性的结构化方法 .16

Agent 互操作性. .19

securing a Single Agent: The Trust Trade-Off. . 21

从单个 Agent 扩展到企业级 Agent 群. . 24

安全与隐私：强化 Agentic 前沿. ..24

Agent governance: A Control Plane instead of Sprawl .. .25

Agent 如何进化与学习 . 26

Agent 如何学习与自进化. .26

模拟与 Agent Gym - 下一个前沿.. . 28

高级 Agent 示例. .29

AlphaEvolve Agent .. . 31

结论.. .33

尾注. .34

## Agent 是语言模型在软件中变得实用的自然进化产物。

## 从预测型 AI 到自主 Agent

人工智能正在发生变化。多年来，重点一直是那些擅长被动、离散任务的模型：回答问题、翻译文本或根据提示生成图像。这种范式虽然强大，但每一步都需要持续的人工指导。我们现在正目睹一场范式转变，从仅仅预测或创造内容的 AI，转向一类能够自主解决问题和执行任务的新型软件。

这个新前沿是围绕 AI Agent 构建的。Agent 不仅仅是静态工作流中的一个 AI 模型；它是一个完整的应用程序，能够制定计划并采取行动以实现目标。它将语言模型（LM）的推理能力与实际行动能力相结合，使其能够处理模型自身无法完成的复杂、多步骤任务。其关键能力在于 Agent 可以独立工作，找出达到目标所需的后续步骤，而无需人类在每个转折点进行引导。

本文档是五部分系列中的第一篇，为那些正在从概念验证（proofs-of-concept）过渡到健壮、生产级 Agentic 系统的开发人员、架构师和产品负责人提供正式指导。虽然构建一个简单的原型很简单，但确保安全性、质量和可靠性是一个重大挑战。本文提供了全面的基础：

核心剖析： 将 Agent 解构为其三个基本组成部分：推理模型、可操作的工具以及起主导作用的编排层。

能力分类： 将 Agent 从简单的、互联的问题解决者分类到复杂的、协作式的多 Agent 系统。

架构设计： 深入探讨每个组件的实际设计考量，从模型选择到工具实现。

面向生产的构建： 建立评估、调试、保护和扩展 Agentic 系统所需的 Agent Ops 规范，实现从单个实例到具有企业治理能力的 Agent 群的扩展。

本指南建立在先前的 Agent 白皮书¹ 和 Agent 伴侣² 的基础之上；提供了成功构建、部署和管理这新一代智能应用所需的基础概念和战略框架，这些应用能够推理、行动和观察以完成目标³。

语言不足以描述人类如何与 \(A /\) 互动。我们倾向于将其拟人化，并使用像“思考”、“推理”和“知道”这样的人类术语。我们还没有词汇来描述“知道语义含义”与“知道最大化奖励函数的高概率”。这是两种不同类型的“知道”，但在 \(9 9 . X \%\) 的时间里，结果是相同的。

## AI Agent 简介

简单来说，一个 AI Agent 可以被定义为模型、工具、编排层和运行时服务的组合，它在一个循环中使用 LM 来完成一个目标。这四个要素构成了任何自主系统的基本架构。

模型（“大脑”）：核心语言模型（LM）或基础模型，作为 Agent 的中央推理引擎，用于处理信息、评估选项并做出决策。模型的类型（通用型、微调型或多模态）决定了 Agent 的认知能力。Agentic 系统是 LM 输入上下文窗口的终极策展者。

工具（“双手”）：这些机制将 Agent 的推理与外部世界连接起来，使其能够执行文本生成之外的操作。它们包括 API 扩展、代码函数以及用于访问实时、事实信息的数据存储（如数据库或向量存储）。Agentic 系统允许 LM 规划使用哪些工具，执行工具，并将工具结果放入下一个 LM调用的输入上下文窗口中。

编排层（“神经系统”）：管理 Agent 操作循环的治理过程。它处理规划、记忆（状态）和推理策略的执行。该层使用提示框架和推理技术（如思维链⁴ 或 ReAct⁵）将复杂目标分解为步骤，并决定何时进行思考与何时使用工具。该层还负责赋予 Agent“记忆”的能力。

部署（“身体和腿”）：虽然在笔记本电脑上构建 Agent 对于原型设计很有效，但生产部署才能使其成为可靠且可访问的服务。这涉及将 Agent 托管在安全、可扩展的服务器上，并将其与用于监控、日志记录和管理的基本生产服务集成。一旦部署，用户就可以通过图形界面访问 Agent，或者其他 Agent 也可以通过 Agent-to-Agent (A2A) API 以编程方式访问它。

归根结底，构建生成式 AI Agent 是一种开发解决方案以解决任务的新方法。传统的开发人员扮

演着“砌砖工”的角色，精确定义每一个逻辑步骤。相比之下，Agent 开发人员更像是一位“导演”。您无需为每个动作编写显式代码，而是设置场景（指导性说明和提示）、选择演员（工具和API）并提供必要的背景（数据）。主要任务变成了引导这个自主的“演员”来交付预期的表现。

您会很快发现，LM 最大的优势——其令人难以置信的灵活性——也是您最大的难题。大型语言模型无所不能的能力使其很难被强制可靠且完美地做好一件特定的事情。我们过去称之为“提示工程”而现在称为“上下文工程”的实践，旨在引导 LM 生成期望的输出。对于 LM 的每一次调用，我们都会输入我们的指令、事实、可用的工具、示例、会话历史、用户画像等——用恰到好处的信息填充上下文窗口，以获得我们需要的输出。Agent 就是管理 LM 输入以完成工作的软件。

当出现问题时，调试变得至关重要。“Agent Ops”实质上重新定义了我们熟悉的测量、分析和系统优化的循环。通过追踪和日志，您可以监控 Agent 的“思考过程”，以识别偏离预期执行路径的情况。随着模型的发展和框架的改进，开发人员的角色是提供关键组件：领域专业知识、明确的个性以及与完成实际任务所需工具的无缝集成。必须记住，全面的评估和评测通常比初始提示的影响更重要。

当一个 Agent 配置精确，拥有清晰的指令、可靠的工具、作为记忆的集成上下文、出色的用户界面、规划和解决问题的能力以及通用世界知识时，它就超越了“工作流自动化”的概念。它开始作为一个协作实体运作：成为您团队中一个高效、适应性强且能力非凡的新成员。

本质上，Agent是一个致力于上下文窗口策展艺术的系统。它是一个不懈的循环：组装上下文、提示模型、观察结果，然后为下一步重新组装上下文。 \(\mathcal { L }\) 下文可能包括系统指令、用户输入、会话历史、长期记忆、来自权威来源的基础知识、可以使用的工具以及已经调用的工具的结果。这种对模型注意力的复杂管理使其推理能力能够解决新情况下的问题并完成目标。

### Agentic 问题解决流程

我们将 AI Agent 定义为一个完整的、面向目标的应用程序，它集成了推理模型、可操作的工具和治理性的编排层。一个简短的版本是“LM 在一个带有工具的循环中以完成一个目标”。

但这个系统实际上是如何工作的呢？从接收请求到交付结果，Agent 究竟做了什么

其核心是，Agent 运行在一个连续的、循环的过程中以实现其目标。虽然这个循环可能变得非常复杂，但它可以被分解为五个基本步骤，如《Agentic 系统设计》⁶ 一书中详细讨论的：

1. 获取任务： 该过程由一个特定的、高层次的目标启动。这个任务由用户提供（例如，“为我们团队组织即将到来的会议差旅”）或由自动触发器启动（例如，“收到一个新的高优先级客户工单”）。  
2. 扫描场景： Agent 感知其环境以收集上下文。这涉及编排层访问其可用资源：“用户的请求说了什么？”，“我的短期记忆中有什么信息？我是否已经尝试过这个任务？用户上周是否给过我指导？”，“我能从我的工具（如日历、数据库或 API）中访问什么？  
3. 思考分析： 这是 Agent 的核心“思考”循环，由推理模型驱动。Agent 对比任务（步骤 1）和场景（步骤 2）进行分析，并制定一个计划。这通常不是单一的想法，而是一个推理链：“要预订差旅，我首先需要知道团队里有谁。我将使用 get_team_roster 工具。然后我需要通过 calendar_api 检查他们的日程。”  
4. 采取行动： 编排层执行计划的第一个具体步骤。它选择并调用适当的工具——调用 API、运行代码函数或查询数据库。这是 Agent 在其内部推理之外对世界采取的行动。  
5. 观察与迭代： Agent 观察其行动的结果。get_team_roster 工具返回了一个包含五个名字的列表。这个新信息被添加到 Agent 的上下文或“记忆”中。然后循环重复，返回到步骤 3：“既然我有了名单，我的下一步是为这五个人检查日历。我将使用 calendar_api。

这个“思考、行动、观察”的循环——由编排层管理，由模型推理，并由工具执行——将持续进行，直到 Agent 的内部计划完成，最初的任务得以实现。

![](images/2f529d2fddbdb6d4d61e71d6e93911affca4706ca53003186c93d3c8c70ea896.jpg)  
图 1：Agentic AI 问题解决流程

让我们来看一个客户支持 Agent 在这个 5 步循环中如何运作的真实示例：

假设一个用户问：“我的订单 #12345 在哪里？”

Agent 不会立即行动，而是首先进入其“思考分析”阶段，以制定一个完整的策略。它推理出：

“用户想要配送状态。为了提供一个完整的答案，我需要一个多步骤计划：

1. 识别： 我必须首先在我们的内部数据库中找到该订单，以确认它存在并获取其详细信息。  
2. 追踪： 从这些详细信息中，我需要提取物流承运商的追踪号码。然后，我将查询外部承运商的 API 以获取实时状态。  
3. 报告： 最后，我必须将收集到的信息整合成一个清晰、有帮助的回复给用户。”

有了这个多步骤计划，Agent 开始执行。

在它的第一个“行动”阶段，它执行计划的第一步，调用 find_order("12345") 工具。它观察到结

果— 一个完整的订单记录，包括追踪号码“ZYX987”。

Agent 的编排层识别到其计划的第一部分已完成，并立即进入第二部分。它通过调用get_shipping_status("ZYX987") 工具来“行动”。它观察到新的结果：“正在派送中”。

最后，成功执行了计划的数据收集阶段后，Agent 进入“报告”步骤。它感知到已拥有所有必要组件，规划了最终消息，并通过生成回复来“行动”：“您的订单 #12345 ‘正在派送中’！”

# Agentic 系统分类

理解 5 步操作循环是拼图的第一部分。第二部分是认识到这个循环可以通过增加复杂性来创建不同类别的 Agent。对于架构师或产品负责人来说，一个关键的初始决策是确定要构建哪种类型的Agent。

我们可以将 Agentic 系统分为几个大的级别，每个级别都建立在上一级别的能力之上。

![](images/638d6ca9024773cc9ecaa48a8356d57a89aafdae75eb6b5cb4210a24c5e24439.jpg)  
图 2：Agentic 系统的 5 个级别

## 级别 0：核心推理系统

在拥有 Agent 之前，我们必须从最基本形式的“大脑”开始：推理引擎本身。在这种配置中，语言模型（LM）独立运行，仅基于其庞大的预训练知识进行响应，没有任何工具、记忆或与实时环境的交互。

它的优势在于这种广泛的训练，使其能够深入解释既定概念并规划如何解决问题。其代价是完全缺乏实时意识；它功能上“盲目”于其训练数据之外的任何事件或事实。

例如，它可以解释职业棒球的规则和纽约洋基队的完整历史。但如果你问，“昨晚洋基队比赛的最终比分是多少？”，它将无法回答。那场比赛是在其训练数据收集之后发生的特定、真实世界的事

件，所以该信息在它的知识中根本不存在。

## 级别 1：互联的问题解决者

在这个级别，推理引擎通过连接并利用外部工具——我们架构中的“双手”组件——成为一个功能性的 Agent。它解决问题的能力不再局限于其静态的、预训练的知识。

使用 5 步循环，Agent 现在可以回答我们之前的问题。给定“任务”：“昨晚洋基队比赛的最终比分是多少？”，它的“思考”步骤将其识别为实时数据需求。其“行动”步骤随后调用一个工具，比如带有正确日期和搜索词的 Google 搜索 API。它“观察”搜索结果（例如，“洋基队 5-3 获胜”），并将该事实合成为最终答案。

这种与世界互动的基本能力——无论是使用搜索工具查询比分、使用金融 API 获取实时股价，还是通过检索增强生成（RAG）查询数据库——是级别 1 Agent 的核心能力。

## 级别 2：战略性问题解决者

级别 2 标志着能力的显著扩展，从执行简单任务转向战略性地规划复杂、多部分的目标。这里出现的关键技能是上下文工程：Agent 能够为其计划的每一步主动选择、打包和管理最相关的信息。

Agent 的准确性依赖于一个专注、高质量的上下文。上下文工程管理模型的有限注意力，以防止过载并确保高效性能。

例如，考虑这个“任务”：“在我的办公室（1600 Amphitheatre Parkway, Mountain View）和我的客户办公室（1 Market St, San Francisco）之间，找一个好的中途咖啡店。”

一个级别 2 的 Agent 将开始创建一个计划：

1. 思考： “我必须首先找到中点。”

行动： 使用两个地址调用地图工具。

观察： “中点是加利福尼亚州米尔布雷（Millbrae, CA）。”

2. 思考： “现在我必须在米尔布雷找咖啡店。用户要求‘好的’，所以我会搜索评分为 4 星或更

高的地方。”

行动：调用 `google_places` 工具，查询="coffee shop in Millbrae, CA",`min_rating \(\mathord {  } 4 . 0\) （**这就是上下文工程**——它根据上一步的输出自动创建了一个新的、专注的搜索查询）。

观察：** “搜索返回‘Millbrae Coffee’和‘The Daily Grind’。”

3. 思考： “我将综合这些结果并呈现给用户。”

这种战略规划还支持主动协助，比如一个 Agent 读取一封长的航班确认邮件，工程化关键上下文（航班号、日期），并“行动”将其添加到您的日历中。

## 级别 3：协作式多 Agent 系统

在最高级别，范式完全转变。我们不再构建一个单一、全能的“超级 Agent”，而是转向一个协同工作的“专家团队”，这个模型直接模仿了人类组织。系统的集体力量在于这种劳动分工。

在这里，Agent 将其他 Agent 视为工具。想象一个“项目经理” Agent 接收到一个“任务”：“发布我们的新‘Solaris’耳机。

项目经理 Agent 不会自己完成全部工作。它通过为其专业 Agent 团队创建新“任务”来“行动”，就像现实生活中的工作方式一样：

1. 分配给 MarketResearchAgent： “分析降噪耳机的竞品定价。明天前返回一份摘要文件。”  
2. 分配给 MarketingAgent： “使用‘Solaris’产品规格表作为上下文，起草三个版本的新闻稿。”  
3. 分配给 WebDevAgent： “根据附加的设计模型生成新产品页面的 HTML。

这种协作模型，虽然目前受到当今 LM 推理能力的限制，但代表了从头到尾自动化整个复杂业务工作流的前沿。

## 级别 4：自进化系统

级别 4 代表了从委托到自主创造和适应的深刻飞跃。在这个级别，Agentic 系统可以识别自身能

力的差距，并动态创建新工具甚至新 Agent 来填补这些差距。它从使用一组固定的资源转变为主动扩展这些资源。

延续我们的例子，“项目经理” Agent 在负责“Solaris”发布任务时，可能意识到它需要监控社交媒体情绪，但其团队中不存在这样的工具或 Agent。

1. 思考（元推理）： “我必须追踪‘Solaris’的社交媒体热议，但我缺乏这种能力。”  
2. 行动（自主创造）： 它不会失败，而是调用一个高级别的 AgentCreator 工具，并赋予一个新任务：“构建一个新 Agent，用于监控社交媒体上的关键词‘Solaris 耳机’，执行情感分析，并报告每日摘要。”  
3. 观察： 一个新的、专门的 SentimentAnalysisAgent 被即时创建、测试并添加到团队中，准备为原始任务做出贡献。

这种级别的自主性，即系统可以动态扩展自身的能力，将一个 Agent 团队转变为一个真正学习和进化的组织。

# 核心 Agent 架构：模型、工具与编排

我们知道了 Agent 能做什么以及它如何扩展。但我们究竟如何构建它呢？从概念到代码的转变在于其三个核心组件的具体架构设计。

## 模型：AI Agent 的“大脑”

LM 是您 Agent 的推理核心，它的选择是一个关键的架构决策，决定了您 Agent 的认知能力、运营成本和速度。然而，将这个选择简单地视为挑选基准分数最高的模型，是通往失败的常见路径。Agent 在生产环境中的成功很少由通用的学术基准决定。

现实世界的成功需要一个在 Agentic 基础能力上表现出色的模型：卓越的推理能力以驾驭复杂的多步骤问题，以及可靠的工具使用能力以与世界互动⁷。

要做到这一点，首先要定义业务问题，然后根据直接映射到该结果的指标来测试模型。如果您的Agent 需要编写代码，请在您的私有代码库上测试它。如果它处理保险索赔，请评估其从您特定文档格式中提取信息的能力。然后必须将此分析与成本和延迟的实用性进行交叉引用。“最佳”模型是那个在您特定任务的质量、速度和价格的最佳交集上的模型。

您可能会选择不止一个模型，一个“专家团队”。你不会用大锤去砸坚果。一个健壮的 Agent 架构可能会使用像 Gemini 2.5 Pro 这样的前沿模型来进行初步规划和复杂推理的重任，但随后智能地将更简单、高容量的任务— —比如分类用户意图或总结文本——路由到像 Gemini 2.5 Flash 这样更快、更具成本效益的模型。模型路由可能是自动的或硬编码的，但它是优化性能和成本的关键策略。

同样的原则也适用于处理不同类型的数据。虽然像 Gemini 实时模式¹⁰ 这样的原生多模态模型为处理图像和音频提供了一条简化的路径，但另一种选择是使用专门的工具，如 Cloud VisionAPI¹¹ 或 Speech-to-Text API¹²。在这种模式下，世界首先被转换为文本，然后传递给仅语言模型进行推理。这增加了灵活性，并允许使用同类最佳的组件，但也引入了显著的复杂性。

最后，AI 领域正处于持续、快速的进化之中。您今天选择的模型将在六个月内被超越。“一劳永

逸”的心态是不可持续的。为此而构建意味着投资于一个灵活的操作框架— 种“Agent Ops”实践¹³。通过一个健壮的 CI/CD 管道，根据您的关键业务指标持续评估新模型，您可以降低升级风险并加速升级，确保您的 Agent 始终由可用的最佳大脑提供动力，而无需进行彻底的架构改革。

## 工具：AI Agent 的“双手”

如果模型是 Agent 的大脑，那么工具就是将其推理与现实连接起来的双手。它们允许 Agent 超越其静态训练数据，以检索实时信息并在世界上采取行动。一个健壮的工具接口是一个三部分的循环：定义工具能做什么、调用它，以及观察结果。

以下是 Agent 构建者会放入其 Agent“手中”的几种主要工具类型。本系列中以 Agent 工具为重点的白皮书将进行更完整的深入探讨。

### 检索信息：立足于现实

最基础的工具是访问最新信息的能力。检索增强生成（RAG）给了 Agent 一张“借书卡”，可以查询外部知识，这些知识通常存储在向量数据库或知识图谱中，范围从内部公司文档到通过Google 搜索获取的网络知识。对于结构化数据，自然语言到 SQL（NL2SQL）工具允许 Agent查询数据库以回答分析性问题，如“上个季度我们最畅销的产品是什么？”通过在说话前查找信息——无论是在文档中还是在数据库中——Agent 将自己立足于事实，从而显著减少幻觉。

### 执行操作：改变世界

当 Agent 从读取信息转向主动做事时，它们的真正力量才被释放出来。通过将现有的 API 和代码函数包装为工具，Agent 可以发送电子邮件、安排会议或在 ServiceNow 中更新客户记录。对于更动态的任务，Agent 可以即时编写和执行代码。在安全的沙箱中，它可以生成 SQL 查询或Python 脚本来解决复杂问题或执行计算，将其从知识渊博的助手转变为自主的行动者¹⁴。

这也包括用于人机交互的工具。Agent 可以使用“人在环路中”（Human in the Loop, HITL）工具来暂停其工作流并请求确认（例如，ask_for_confirmation()）或从用户界面请求特定信息（例如，ask_for_date_input()），确保人类参与关键决策。HITL 可以通过短信和数据库中的任务来

实现。

### 函数调用：将工具连接到您的 Agent

为了让 Agent 可靠地进行“函数调用”并使用工具，它需要清晰的指令、安全的连接和编排¹⁵。像OpenAPI 规范这样的长期标准提供了这一点，为 Agent 提供了一个结构化的契约，描述了工具的用途、所需参数及其预期响应。该模式使模型每次都能生成正确的函数调用并解释 API 响应。为了更简单地发现和连接工具，像模型上下文协议（MCP）¹⁶ 这样的开放标准因其更便捷而变得流行。此外，一些模型具有原生工具，如 Gemini 的原生 Google 搜索，其中函数调用本身就是 LM 调用的一部分¹⁷。

## 编排层

如果模型是 Agent 的大脑，工具是它的双手，那么编排层就是连接它们的中枢神经系统。它是运行“思考、行动、观察”循环的引擎，是治理 Agent 行为的状态机，也是开发人员精心设计的逻辑得以实现的地方。这一层不仅仅是管道；它是整个 Agentic 交响乐的指挥，决定模型何时应该推理，哪个工具应该行动，以及该行动的结果应如何为下一个乐章提供信息。

## 核心设计选择

第一个架构决策是确定 Agent 的自主程度。这个选择存在于一个光谱上。一端是确定性的、可预测的工作流，它调用 LM 作为特定任务的工具——在现有流程中加入一点 AI 来增强。另一端是LM 处于驾驶座，动态地适应、规划和执行任务以实现目标。

一个平行的选择是实现方法。无代码构建器提供速度和可访问性，使业务用户能够快速自动化结构化任务并构建简单的 Agent。对于更复杂、任务关键型的系统，代码优先的框架（如 Google的 Agent 开发工具包 (ADK)¹⁸）提供了工程师所需的深度控制、可定制性和集成能力。

无论采用哪种方法，一个生产级的框架都是必不可少的。它必须是开放的，允许您插入任何模型或工具以防止供应商锁定。它必须提供精确的控制，实现一种混合方法，即 LM 的非确定性推理受到硬编码业务规则的制约。最重要的是，该框架必须为可观测性而构建。当 Agent 行为异常时，您不能简单地在模型的“思想”中设置断点。一个健壮的框架会生成详细的追踪和日志，暴露

整个推理轨迹：模型的内部独白、它选择的工具、它生成的参数以及它观察到的结果。

### 注入领域知识与人设

在这个框架内，开发人员最有力的杠杆是为 Agent 注入领域知识和独特的人设。这是通过系统提示或一组核心指令来完成的。这不仅仅是一个简单的命令；它是 Agent 的“宪法”。

在这里，你告诉它，“你是一个乐于助人的 Acme 公司客户支持 Agent”，并提供约束条件、期望的输出模式、交战规则、特定的语气，以及关于何时以及为何应使用其工具的明确指导。在指令中加入一些示例场景通常非常有效。

### 通过上下文进行增强

Agent 的“记忆”在运行时被编排到 LM 上下文窗口中。本系列中以 Agent 记忆为重点的白皮书将进行更完整的深入探讨。

短期记忆是 Agent 活跃的“草稿纸”，维持当前对话的运行历史。它跟踪正在进行的循环中的（行动，观察）对序列，为模型决定下一步做什么提供即时上下文。这可以实现为状态、工件、会话或线程等抽象。

长期记忆提供跨会话的持久性。在架构上，这几乎总是作为另一个专门的工具来实现— 个连接到向量数据库或搜索引擎的 RAG 系统。编排器使 Agent 能够预取并主动查询其自己的历史，使其能够“记住”用户的偏好或几周前类似任务的结果，以获得真正个性化和连续的体验。¹⁹

## 多 Agent 系统与设计模式

随着任务复杂性的增加，构建一个单一、全能的“超级 Agent”变得低效。更有效的解决方案是采用“专家团队”方法，这模仿了人类组织。这是多 Agent 系统的核心：一个复杂的过程被

分割成离散的子任务，每个子任务都被分配给一个专门的、专业的 AI Agent。这种劳动分工使得每个 Agent 更简单、更专注，并且更容易构建、测试和维护，这对于动态或长期运行的业务流程是理想的。

架构师可能依赖经过验证的 Agentic 设计模式，尽管 Agent 的能力和模式正在迅速发展。²⁰ 对

于动态或非线性任务，**协调器（Coordinator）**模式至关重要。它引入了一个“经理”

Agent，该 Agent 分析复杂请求，分割主要任务，并智能地将每个子任务路由到适当的专家

Agent（如研究员、作者或程序员）。然后，协调器聚合来自每个专家的响应，以形成最终的、

全面的答案。

![](images/056c0b17bd9c463bc14483609e6887dc15d60c2f4ea19a22a4b8870ab8612ded.jpg)  
图 3：来自 https://cloud.google.com/architecture/choose-design-pattern-agentic-ai-system 的“迭代优化”模式

对于更线性的工作流，**顺序（Sequential）**模式是更好的选择，它就像一个数字装配线，一个 Agent 的输出成为下一个 Agent 的直接输入。其他关键模式关注质量和安全。**迭代优化（Iterative Refinement）**模式创建了一个反馈循环，使用一个“生成器” Agent 来创建内容，并使用一个“批评家” Agent 来根据质量标准对其进行评估。

对于高风险任务，**人在环路中（HITL）**模式至关重要，它在工作流中创建一个故意的暂停，以便在 Agent 采取重大行动之前获得人类的批准。

# Agent 部署与服务

在您构建了本地 Agent 之后，您会希望将其部署到服务器上，使其可以全天候运行，并且其他人

和其他 Agent 都可以使用它。继续我们的类比，部署和服务将是我们 Agent 的身体和腿。一个

Agent 需要多种服务才能有效运作，例如会话历史和记忆持久化等。作为 Agent 构建者，您还将

负责决定记录什么内容，以及为数据隐私、数据驻留和法规遵从性采取什么安全措施。所有这些

服务都在将 Agent 部署到生产环境的范围之内。

幸运的是，Agent 构建者可以依赖几十年的应用程序托管基础设施。Agent 毕竟是一种新形式的软件，许多相同的原则也适用。构建者可以依赖专门构建的、特定于 Agent 的部署选项，如Vertex AI Agent 引擎，它在一个平台²¹中支持运行时和所有其他功能。对于希望更直接地控制其应用程序堆栈，或在其现有 DevOps 基础设施内部署 Agent 的软件开发人员，任何 Agent 和大多数 Agent 服务都可以添加到 Docker 容器中，并部署到行业标准运行时（如 Cloud Run 或GKE²²）上。

![](images/965b07783f552a6db59d6566c92e74ede8e5d6aec6d81b76762e2ffae43f4b34.jpg)  
图 4：来自 https://cloud.google.com/vertex-ai/generative-ai/docs/agent-engine/overview 的 Vertex AI Agent 构建器

如果您不是软件开发人员和 DevOps 专家，部署第一个 Agent 的过程可能会令人望而生畏。许多 Agent 框架通过一个 deploy 命令或一个专门的平台来简化这一过程，这些应该用于早期探索和入门。要升级到一个安全且生产就绪的环境，通常需要投入更多的时间并应用最佳实践，包括CI/CD 和 Agent 的自动化测试²³。

# Agent Ops：应对不可预测性的结构化方法

当您构建第一个 Agent 时，您将一遍又一遍地手动测试其行为。当您添加一个功能时，它是否有效？当您修复一个错误时，您是否引发了另一个问题？测试对于软件开发来说是正常的，但对于生成式 AI 而言，它的工作方式有所不同。

从传统的、确定性的软件到随机的、Agentic 系统的转变，需要一种新的运营理念。传统的软件单元测试可以简单地断言 output == expected；但这在 Agent 的响应是概率性设计时行不通。此外，由于语言是复杂的，通常需要一个 LM 来评估“质量”——即 Agent 的响应是否完成了所有应该做的事情，没有做不应该做的事情，并且具有适当的语气。

![](images/8950fc53cc695f312b3d727009087b0df7c0846eb1572effaacef64e4a153cb6.jpg)  
图 5：来自 https://medium.com/@sokratis.kartakis/genai-in-production-mlops-or-genaiops-25691c9becd0 的 DevOps、MLOps 和 GenAIOps 运营领域之间的关系

Agent Ops 是管理这一新现实的规范、结构化方法。它是 DevOps 和 MLOps 的自然演进，专为构建、部署和治理 AI Agent 的独特挑战而量身定制，将不可预测性从一种负债转变为一种可管理、可测量且可靠的特性。²⁴ 本系列中以 Agent 质量为重点的白皮书将进行更完整的深入探讨。

## 衡量关键指标：像 A/B 实验一样检测成功

在您改进 Agent 之前，您必须在您的业务背景下定义“更好”意味着什么。像 A/B 测试一样构建您的可观测性策略，并问自己：证明 Agent 正在交付价值的关键绩效指标（KPI）是什么？这些指标应超越技术正确性，衡量真实世界的影响：目标完成率、用户满意度得分、任务延迟、每次交互的运营成本，以及——最重要的是——对业务目标（如收入、转化率或客户保留率）的影响。这种自上而下的视图将指导您余下的测试，使您走上指标驱动开发的道路，并让您能够计算